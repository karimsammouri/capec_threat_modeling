# Imports
import os
from dotenv import load_dotenv
from flask import Flask, render_template, request
from openai import OpenAI
import chromadb
from chromadb.utils import embedding_functions

# Flask application initialization
app = Flask(__name__)

# Load OpenAI API key as environment variable
load_dotenv()

# Initialize OpenAI client
openai_client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Core functions
def decompose_system(system_description):
    """Decompose a given system using data flow diagram elements for threat modeling."""
    system_prompt = (
        "You are a system analyst specialized in threat modeling. "
        "Your task is to analyze and decompose systems using data flow diagram (DFD) elements, "
        "focusing on identifying external entities, processes, data stores, and data flows. "
        "You respond in plain text instead of Markdown."
    )
    system_decomposition_prompt = (
        "I'll give you a textual description of a system. "
        "Decompose this system using data flow diagram (DFD) elements for threat modeling. "
        "Stucture your response as follows: external entities, processes, data stores, and data flows. "
        "Output only plain text. Do not output Markdown. "
        "The system description is as follows:\n" + system_description
    )
    system_decomposition = openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": system_decomposition_prompt}
        ]
    )
    decomposed_system = system_decomposition.choices[0].message.content
    return decomposed_system

def identify_threats(decomposed_system):
    """Identify relevant attack patterns for a decomposed system."""
    system_prompt = (
        "You are a cybersecurity expert specializing in threat modeling. "
        "Your task is to identify relevant attack patterns for components of a decomposed system, "
        "analyzing external entities, processes, data stores, and data flows. "
        "You respond in plain text instead of Markdown."
    )
    threat_identification_prompt = (
        "I'll give you a decomposed system. "
        "Identify relevant attack patterns for each system component (external entities, processes, data stores, and data flows). "
        "Maintain the structure of the input in your output. "
        "Output only plain text. Do not output Markdown. "
        "The decomposed system is as follows:\n" + decomposed_system
    )
    threat_identification = openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": threat_identification_prompt}
        ]
    )
    identified_threats = threat_identification.choices[0].message.content
    return identified_threats

def generate_dictionary(identified_threats):
    """Convert identified threats into an iterable Python dictionary."""
    system_prompt = (
        "You are a Python programmer tasked with transforming structured threat modeling data into Python dictionaries. "
        "Your output should strictly adhere to valid Python syntax and be directly parsable as a Python object."
        "You respond in plain text instead of Markdown."
    )
    dictionary_generation_prompt = (
        "I'll give you a listing of system components and related threats that are organized around data-flow diagram (DFD) elements. "
        "Return a Python dictionary where each DFD element points to another dictionary of system components, "
        "where each system component points to a list of threats. "
        "Just provide the code that will be parsed to a Python object. "
        "Output only plain text. Do not output Markdown. "
        "The threat listing is as follows:\n" + identified_threats
    )
    dictionary_generation = openai_client.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": dictionary_generation_prompt}
        ]
    )
    generated_dictionary = dictionary_generation.choices[0].message.content
    print(f"Python dictionary generated by LLM: \n{generated_dictionary}")
    threat_dictionary = {}
    try:
        threat_dictionary = eval(generated_dictionary)
    except Exception as e:
        print(f"There was an error evaluating the LLM-generated string as Python code: {e}")
    return threat_dictionary

def retrieve_entries(threat_dictionary):
    """Retrieve relevant CAPEC entries from the ChromaDB vector database."""
    chroma_client = chromadb.PersistentClient(path="chroma")
    openai_ef = embedding_functions.OpenAIEmbeddingFunction(
        api_key=os.getenv("OPENAI_API_KEY"),
        model_name="text-embedding-3-large"
    )
    collection = chroma_client.get_or_create_collection(
        name="capec",
        metadata={"hnsw:space": "cosine"},
        embedding_function=openai_ef
    )
    retrieved_entries = []
    for dfd_element, system_components in threat_dictionary.items():
        element_node = {
            "text": f"<i>{dfd_element}</i>",
            "state": {"opened": True},
            "children": []
        }
        for system_component, threats in system_components.items():
            component_node = {
                "text": system_component,
                "state": {"opened": True},
                "children": []
            }
            for threat in threats:
                capec_entry = collection.query(
                    query_texts=[f"Threat: {threat} (Associated System Component: {system_component})"], 
                    n_results=1, 
                    include=["documents"]
                )
                capec_dictionary = eval(capec_entry["documents"][0][0])
                likelihood_of_attack = capec_dictionary.get("Likelihood Of Attack")
                typical_severity = capec_dictionary.get("Typical Severity")
                threat_node = {
                    "text": f'<mark>"{threat}"</mark>',
                    "state": {"opened": False},
                    "data": {"likelihood": likelihood_of_attack, "severity": typical_severity},
                    "children": []
                }
                for key, value in capec_dictionary.items():
                    row_node = {
                        "text": f"<b>CAPEC {key}:</b> {value if value else '<i>N/A</i>'}"
                    }
                    threat_node["children"].append(row_node)
                component_node["children"].append(threat_node)
            element_node["children"].append(component_node)
        retrieved_entries.append(element_node)
    return retrieved_entries

# Flask routes
@app.route("/")
def index():
    return render_template("index.html")

@app.route("/decompose_system", methods=["POST"])
def decompose():
    system_description = request.data.decode("utf-8")
    decomposed_system = decompose_system(system_description)
    return decomposed_system

@app.route("/identify_threats", methods=["POST"])
def identify():
    decomposed_system = request.data.decode("utf-8")
    identified_threats = identify_threats(decomposed_system)
    return identified_threats

@app.route("/retrieve_entries", methods=["POST"])
def retrieve():
    identified_threats = request.data.decode("utf-8")
    generated_dictionary = generate_dictionary(identified_threats)
    retrieved_entries = []
    if not generated_dictionary:
        retrieved_entries = ["There was an error in retrieving the relevant CAPEC entries."]
    else:
        retrieved_entries = retrieve_entries(generated_dictionary)
    return retrieved_entries
    
# Run the Flask app
if __name__ == "__main__":
    app.run(debug=True)